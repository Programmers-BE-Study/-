## 순환 참조 
: 순환 참조는 그냥 얼굴에 침뱉기임 -> 면죄부로 양방향 매핑.. 

## 안티패턴
### 스마트UI 
`controller`에 너무 많은 역할을 준 형태 하면 안됨  -> 서비스 로직도 들고 있는 유능하지만 노예같은 회사원 느낌 하면 안됨..

### 양방향 레이어드 아키텍처 
레이어드 아키텍처에서 정의한 레이어들의 의존관계에 양방향 의존이 발생하는 경우 -> 사실상 순환참조인듯?

### 트랜잭션 스크립트 
비즈니스 레이어에 위치하는 서비스 컴포넌트에서 발생하는 안티패턴
서비스 컴포넌트의 구현이 사실상 어떤 **트랜잭션이 걸려있는 스크립트**를 실행하는 것 처럼 보일 때 
(스마트 UI의 서비스 버전이라고 생각해도 될듯) -> 알고리즘 덩어리 -> 절차지향적일 확률 Up

### 서비스
: `DDD(도메인 주도 설계 : 도메인을 탐색하고, 탐색 내용을 바탕으로 SW 설계)`에서 시작된.. 개념 
캡술화된 상태 없이, 모델과는 독립된 동작을 제공하는 인터페이스
- DDD 에서 도메인은 비즈니스 영역이며 문제 영역이다
- DDD 에서 서비스는 도메인 문제를 해결하기 위한 패턴 중 하나
- 서비스는 객체(도메인)가 처리하기에 애매한 연산 로직을 갖고 있는 컴포넌트
- 도메인 개발에 필요하지만 객체로 펴현하기 애매한 로직을 처리하는 서비스를 `도메인 서비스`라 함
- 애플리케이션 개발에 필요하지만 객체로 표현하기 애매한 로직을 처리하는 서비스를 `애플리케이션 서비스`라고 함<br>
객체지향 관점으로 보는 서비스
- 서비스는 가능한 적게 만들고, 얇게 유지 -> 로직의 길이가 최대한 짧게 -> 도메인 객체로 옮겨 
	- 이 때 고민할 수 있는게 기존의 도메인 객체에 들어갈 수 있는가? 
	- 없다면 새로 도메인 모델로 만들 수는 없는지? 
- 서비스보다 풍부한 도메인 모델을 만들어야 함 -> 위와 같은 결론이 나겠네
- 서비스는 불변성을 가짐 -> 계산식 그자체임 -> 같은 논리 입력받으면 같은 응답이 당연함  -> 생성자 주입을 하는게 유리함 -> @RequireArgsConstructor 만세<br>
서비스 관련 행동 조언
- 서비스의 멤버 변수는 모두 final
- 서비스에 세터 지양
- 반드시 생성자 주입 @RequireArgsConstructor 만세
- 비즈니스 로직을 도메인에 양보
- 얇게 유지 

###  아키텍처
**아키텍처** : 구조에 제약을 걸면 아키텍처라고 할 수 있음
	-  아키텍처는 제약 조건을 이용해 해도 되는 것과 안되는 것을 결정하고 이를 개발단계에서 일어나지 않게 원천 차단함
	- 정책과 같음

#### 레이어드 아키텍처
- 레이어 구조를 사용
- 레이어 간 의존 방향은 단방향으로 유지
- 레이어 간 통신은 인접한 레이어에서만 이뤄지도록 함
`Controller
`Service
`JpaRepository

아키텍처 관해 이야기할 때 세부사항은 최대로 미뤄라.. Spring, JPA는 세부사항이므로 
우선 도메인에 따른 기술 스택이 설정되어야 함 

#### 진화한 레이어드 아키텍처 
애플리케이션의 본질은 도메인이므로 개발 첫 시작은 `도메인`에서 부터 시작함 
`Controller`
`Service` `interface Repository` => `infra` 레이어의 `RepositoryImpl` 로 구현
`Domain` 
- 주요 도메인 객체들 표현 (순수 자바 코드로만 작성해야 됨 @Service, @Entity와 같이 Spring JPA 어노테이션 지양)
`infra`  `RepositoryImpl` 의존->  `JpaRepository`

#### 더 진화한 레이어드 아키텍처 (유사 헥사고날)
`Controller` `interface Service`
`ServiceImpl` `interface Repository` => `infra` 레이어의 `RepositoryImpl` 로 구현
`Domain`
`RepositoryImpl` 의존 -> `interface JpaRepository`

발전된 레이어드 아키텍처 --> 헥사고날 
의존성 역전 = `포트-어댑터 패턴`
#### 진짜 헥사고날
![[Pasted image 20241021200614.png]]

- 목적 : 
	- 애플리케이션의 핵심인 내부세계(도메인), 바깥세계(예: 웹 요청, 데이터베이스 호출 등)를 명확하게 분리하고 **도메인이 외부 세계와 완전히 독립적으로 동작**
- 좌측의 입력(input) : 
	- 애플리케이션을 사용하는 사용자들의 입력을 표현
	- 입력 어댑터는 입력포트 (input port)를 통해 입력 받은 내용을 ServiceImpl(UserCase)컴포넌트로 전달
- serviceImpl 컴포넌트는 우리가 알던 애플리케이션 서비스 
	- 데이터 베이스에서 도메인을 가져오고 네트워크 호출하고, 도메인 업무를 위임하는 역할
- 우측의 출력(output) :
	- 도메인 영속화 
	- 시스템을  호출하는 상황을 표현
- 긍정적 의견
	- 경계를 강제할 수 있게 됨
	- 외부 세계와 내부 세계에서 벌어지는 모든 일에 일관된 패턴을 적용할 수 있음
	- 프레젠테이션 레이어에 있는 컴포넌트를 테스트가 쉬워짐
- 부정적 의견
	- 의존성 역전을 적용했을 때 얻을 수 있는 실효성이 모호함
	- 의존성 역전을 적용하지 않아도 도메인 모델은 외부 세계에 독립적
	- 애플리케이션 레이어가 프레젠테이션 레이어에 의존하는 것이 부자연스러움

#### 모듈
: 라이브러리와 프로그램의 구성 요소 사이에 위치하는 개념
- 독립성
- 은닉성
SW 관점에서 위의 특징들을 만족하며 연관된 코드들의 묶음

 모듈 시스템 
	: 연관된 코드 묶음이 `모듈성`을 갖출 수 있게 도와주는 시스템적인 해결책, 모듈성을 지원하기 위해 모듈 시스템은 다음과 같은 기능을 필수적으로 지원해야 함
	- 의존성 관리
		- 모듈을 사용하기 위해 어떤 의존성이 필요한지 명시할 수 있어야 함
	- 캡슐화 관리
		- 모듈은 불필요한 구현을 외부로 드러내지 않아야함

- 모듈은 연관된 코드의 묶음이 모듈성을 갖춘 경우 모듈이라고 부를 수 있음
- 모듈성에는 `독립성`, `은닉성`이라는 특징이 있음
- 모듈성을 갖출 수 있게 도와주는 시스템이 `모듈 시스템`
- 모듈 시스템은 모듈성 중 `독립성`을 지원하기 위해 `의존성 관리 기능`을 지원할 수 있어야 함
- 모듈 시스템은 모듈성 중 `은닉성`을 지원하기 위해 `캡슐화 관리 기능`을 지원할 수 있어야 함

은닉성
	: 모듈이나 패키지 수준까지 발전할 수 있음

독립성
	: 다른 모듈이나 컴포넌트에 강하게 의존하지 않고 각 모듈을 개별적으로 수정하거나 교체할 수 있어야 함
		- 유지보수성 
		- 확장성
		- 코드 재사용성
		에 유리함 
	- 최대한 내부에서 해결 
	- 외부에 강하게 의존 X
	- **외부 시스템을 사용한다면 외부 시스템의 사용을 명시**

#### 통합하기 전략과 분리하기 전략

- 통합하기 전략
	- 도메인과 영속성 객체 통합
	- 장점 
		- 하나의 클래스만 잘 관리하면 됨
		- 개발 속도가 빠름
		- JPA 역할이 ORM이라는 점을 상기했을 때 매우 자연스러운 선택
	- 단점
		- 클래스의 책임이 제대로 눈에 들어오지 않음
		- 단일 책임 원칙 위반
		- 도메인이 영속성 라이브러리에 강한 결합
- 분리하기 전략
	- 도메인과 영속성 객체 분리
	- 통합하기 전략의 단점이 장점으로 바뀜
	- 통합하기 전략의 장점이 단점 