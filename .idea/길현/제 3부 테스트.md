커버리지를 올리기 위한 `mock` 프레임워크 사용법만 고민하고, 왜 테스트를 해야하고, 어떻게 테스트를 해야하는지 고민하지 않았음 

- 수동 테스트
	- 사람이 직접 손으로 테스트를 하고 결과값을 봄
- 자동 테스트
	- 테스트 코드를 작성하여 컴퓨터가 알아서 테스트를 하고 실패 시 에러나 예외를 발생해 개발자가 알아챌 수 있게 신호를 보냄

## Regression
-  시스템에서 정상적으로 제공하던 기능이 어떤 배포 시점을 기준으로 제대로 동작하지 않게 되는 상황
- 기능 개발이 제대로 돼 있지 않던 과거로 되돌아갔다(회귀)라는 의미 
- Regression bug로 부르는게 좀 더 정확함 
- 발생 경위
	- 개발자가 바뀌면서 이전에 작업했던 코드의 의미를 모르고 수정하면서 주로 발생
	- 위의 이유 때문에 담당자가 바뀐 코드를 수정할 때 소극적
	- 악순환 반복
- 예방법
	- JAVA DOC : 주석을 열심히 달자 
	- 테스트 코드를 작성 -> 코드의 의미를 보여줌 

레거시 코드 :  테스트가 작성이 안된 코드
## 테스트 3분류
- Large 테스트(Api 테스트 / 전체 테스트의 5%)
	- 멀티 서버 
	- End to end 테스트 
- Medium 테스트(통합 테스트 /전체 테스트의 15%)
	- 단일 서버 
	- 멀티프로세스
	- 멀티 스레드 ->  결과가 다를 수 있음
	- h2같은 테스트 DB를 사용할 수 있다
- **samll 테스트(단위 테스트 / 전체 테스트의 80%)
	- 테스트 결과가 항상 결정적(Deterministic)
	- 테스트 속도 빠름
	- 단일 서버
	- 단일 프로세스
	- 단일 스레드
	- 디스크 I/O 사용 X 
	- Blocking call X 


## 테스트 
#### 좋은 테스트의 기준
- 테스트는 결정적이여야 함
	- 결정적이다 = 일관성을 가진다, 동일한 입력에는 동일한 테스트 결과를 가져와야 함
	- 비결정적이다 = 코드를 수정하지 않았는데 결과가 다를 때 (외부 DB 같은 곳에서 오류가 생겨서 실패할 수도 있음)
		- 병렬처리를 사용할 경우
		- 디스크I/O를 사용할 경우
		- 다른 프로세스와 통신할 경우
		- 외부 서버와 통신할 경우
- 테스트의 속도는 빠르게 
	- 속도가 느린 테스트가 만들어지는 경우
		- 블로킹 호출을 사용할 경우 (`Thread.sleep()`)
		- 디스크 I/O를 사용할 경우 (입력/출력을 기다려야겠지?)
		- 다른 프로세스와 통신할 경우
		- 외부 서버와 통신할 경우 
- 이러한 이유로 small 테스트는 금기 사항들이 있음 

#### 테스트 대역
: 스턴트맨 같은 대역임, 테스트를 위해 만들어진 가짜 객체나 컴포넌트 
- Dummy : 빈 깡통
	- 정상적으로 코드가 돌아가게 하기 위한 역할만 
	- 없으면 NPE 발생할 때 그냥 Dummy 만들어서 처리 
- Stub : 지정한 값만 반환 (`when().thenReturn`)
	- 사본과 거의 같은 개념
	- 실체 객체의 응답을 최대한 비슷하게 따라하는 대역
	- 응답을 원본과 똑같이 반환하는데만 집중
- Fake : 자체적인 로직이 있음
	- 모든 테스트에 Stub을 사용하는 코드를 넣기 힘들고 바람직하지도 않음 -> 테스트의 중요한 부분을 가릴 수 있기 때문에
	- 최대한 간결하고 보자마자 이해 가능한 형태로 작성해야 함 Fake 사용 지향
	- 데이터 저장을 간단한 메모리 변수를 갖고 있게 함
- Mock : 아무런 동작을 하지 않음, 대신 어떤 행동이 호출됐는지 기록
	- 메서드 호출 및 상호작용 기록
	- 어떤 객체와 상호 작용이 일어났는지 기록
	- 어떻게 상호작용이 일어났는지 기록
	- Mock은 테스트 대역의 부분 집합
		- 관용적인 의미
			- 테스트 대역과 거의 같은 의미 
		- 개념적인 의미
			- 메서드 호출이 발생했는지를 검증하기 위해 만들어지는 테스트 대역에 해당
			- assertOO 짝꿍
	- 인터페이스를 구현해서 Mock객체를 구현 (@Mock 쓰면 됨 ㅎ)
- Spy : 실제 객체와 똑같이 행동, 모든 행동 호출 기록 
	- 구현체를 가지고 있음
	- 상속을 이용해서 구현(@Spy 쓰면 됨 ㅎ)
	- 프록시 패턴을 이요해서 구현 
```java
//Mock과 Spy의 차이 
@Test
public void mock_versus_spy(){
	//given
	List<Integer> mockList = Mockito.mock(ArrayList.class);
	List<Integer> spyList = Mockito.spy(new ArrayList<Integer>());

	//when
	mockList.add(1);
	spyList.add(1);

	//then.1 둘다 메소드는 호출 됨
	verify(mockList).add(1);
	verigy(spyList).add(1);

	//then.2 진짜 추가 된건 spy만
	assertEquals(mockList.size(), 1) // fail
	assertEquals(spyList.size(),1) // success
}
```

##### 상태 기반 검증 
: 테스트를 실행한 후 테스트 대상의 상태가 어떻게 변화 됐는지 보고 테스트 실행 결과를 판단
```java
@Test
void 유저는_북마크를_toggle_해서_제거할_수_있다(){
//given 
	User user = UserFixture.create();
	user.appendBookmark("foobar"); // bookmark 추가
//when
user.toggleBookmark("foobar"); //bookmark 삭제

//then
//제거 했으니 갖고 있으면 안됨
assertTaht(user.hasBookamrk("foobar")).isFalse();
}
```
##### 행위 기반 검증
: 테스트 검증 동작에 메서드 호출 여부를 보고 판단
- 상호작용 테스트라고도 함 -> 상호작용이란 객체간의 협력
```java
@Test
void 유저는_북마크를_toggle_해서_제거할_수_있다(){
//given
User user = UserFixture.create();
user.appendBookmark("foobar");

//when
user.toggleBookmark("foobar");

//then
verify(user).removeBookmark("foobar"); // removeBookmark()가 호출 됐는지 검증
}
```

행위기반 검증보다 상태기반 검증을 더 지향함 
- 상호작용 테스트가 많아지면 코드가 전체적으로 경직될 수 있음
- 현재 코드 외에 다른 방법으로 개발하는 것이 불가능 -> 서비스 로직 수정할 때 곤란
**테스트 대역을 잘 사용하려면 추삭화가 잘 돼 있어야함 -> 의존성 역전을 잘 해놔야 함
- 테스트 대역을 순수 자바 코드로 작성하려고 했을 대 난황
	- `JpaRepositroy`를 다 구현 해야 함..
	- 라이브러리와 더 강하게 결합하는 형태가 될 수 있음 

#### 테스트 가능성(Testalbility) 
- 테스트 하기 쉬운 코드면 테스트 가능성이 높다
- 반대로 어려우면 가능성이 낮다
숨겨진 입력 ( p.390 한번 더 보기 )
- 랜덤 요소, 시간을 다루는 코드 등 전역 메소드에 의존하는 상황
- getter로 숨겨진 입력을 드러나게 작성 
- 의존성 주입과 의존성 역전을 동시에 사용하는 것 
- 책임에 의존하면 같은 코드를 실행하면서 환경에 따라 컴포넌트를 갈아끼울 수 있게 됨
숨겨진 출력 (p. 401)
- print, log 를 출력하는 경우 Return값은 따로 
- 메소드 구현에 전역 변수를 변경하는 경우
- 메소드 호출의 출력 결과는 반환 값을 통해 드러나는 것이 좋음 -> DTO를 반환하면 얼추 가능
- 이벤트라는 클래스를 만들고 메서드의 반환 값으로 이벤트를 반환 -> DTO랑 뭐가 다르지..?
#### 테스트와 설계 
- 테스트와 소프트웨어 설계는 상호보완적
- 확장할 수 있는 시스템이란 다양한 환경에 이식할 수 있는 시스템
테스트 SRP(단일 책임 원칙)
- 서비스의 책임을 나눠줌 (권장, 개발자 선택임, 테스트에서 신호를 보냄, 액터를 잘 보자 )
- 멤버 변수가 null인 상황은 지양, 피해야 함 Dummy를 꾸준히 넣어주는 편이 나음
테스트 ISP
- 테스트는 인터페이스 분리를 유도함
- 인터페이스가 통합 돼 있으면 필요없는 메소드들까지 모두 구현해야 함 
테스트 OCP, DIP
테스트 LSP
- Right-BICEP 원칙 
	- Right : 결과가 올바른지 확인
	- Boundary : 경계 조건에서  코드가 정상적으로 동작하는지 확인
	- Inverse : 역함수가 있다면 이를 실행해 입력과 일치하는지 확인
	- Cross-Check : 검증에 사용할 다른 수단이 있다면 이를 비교
	- Error Conditions : 오류 상황에서도 프로그램이 의도한 동작을 하는지 확인
	- Performance : 프로그램이 예상한 성능 수준을 유지하는지 확인
- CORRECT 원칙
	- Conformance(적합성) : 데이터 포맷이 제대로 처리되는지 확인
	- Ordering(정렬) : 출력 순서가 보장돼야 한다면 이를 확인
	- Range(범위) : 입력에 양 끝점이 있다면 양 끝점이 들어갈 때 정상 동작하는지 확인 (임계값)
	- Reference(참조) : 협력 객체의 상태에 따라 어떻게 동작하는지 확인
	- Existence(존재) : null, blank 같은 값이 입력될 때 어떻게 반응하는지 확인
	- Cardinaity(원소 개수) : 입력의 개수가 n일 때 어떻게 동작하는지 확인
	- Time(시간) : 병렬 처리를 한다면 순서가 보장되는지 확인 

#### 테스트와 개발 방법론
- TDD(Test - Driven - Development)
	: 코드를 작성하기 전에 코드의 테스트 케이스를 먼저 작성한 후 해당 테스트를 통과할 수 있는 코드를 작성하는 방법 `BDD` 로 이어짐
- BDD (Begavior - driven -development)
	: 소프트웨어 개발 과정에서 비즈니스 요구사항과 소프트웨어의 행동을 강조하는 개발 방법론
	비즈니스 의도를 명확하게 이해하고 테스트 가능한 형태로 작성 
##### TDD 
- Red
	- 로직 구현 전 테스트 케이스를 작성 
	- 당연히 모든 테스트 실패 Green에서 Develop
- Green
	- Red에서 작성한 테스트를 통과하기 위한 `최소한`의 코드 작성
- Blue(Refactor)
	- Green에서 작성한 최소한의 코드를 가독성, 유지보수성, 성능을 높이는데 집중하여 작성
	- 기능은 유지된 상태에서 코드의 `구조`만 변경하는 작업
- 적용하려면 팀원들 모두 테스트 코드를 작성할 줄 알아야 함 
- 개발 속도가 느리다고 할 수 있지만 오히려 장기적인 측면에서 개발 속도가 빠르다고 할 수 있음 
	- 디버깅 시간 단축
	- 코드 변경에 겁먹지 않을 수 있음
	- 코드의 문서 역할을 함 계약
- TDD 절망편
	- 요구사항이 구체적이지 않은 프로젝트에서는 쓰기 힘듬
		- 요구사항이 바뀐다면? 테스트도 고쳐야되고 그냥 처음부터 해야 됨 + 테스트 작성
##### BDD (TDD + DDD)
TDD의 한계인 `어떻게, 무엇을 테스트할거냐?`라는 물음에 발전한 TDD
- 각 객체나 메소드들의 `행동`을 테스트하자 
- TDD는 객체지향적이지 않음 근데 BDD로 발전하면서 어느정도 객체지향이라는 틀에 맞출 수 있게 되었음 -> 행동을 생각해서 객체를 만든다? -> 책임과 역할을 부여한다 -> 어라 객체지향적이네 
- 행동을 테스트하자? -> given when then 패턴
- 사용자 스토리 요구사항 작성
```
제목 : 명시적인 제목

서사
- 주체는누구인가
- 주체가 원하는 것은 무엇인가
- 주체의 행동 결과는 무엇인가

시나리오 #1
- given : 주어진 상황
- when : 시나리오가 발생하는 이벤트
- then : 시나리오 실행에 따른 기댓값

시나리오 #2
- given : 주어진 상황
- when : 시나리오가 발생하는 이벤트
- then : 시나리오 실행에 따른 기댓값
```
![[Pasted image 20240909094415.png]]
BDD가 강조하는 4가지 
- 개발자와 비개발자 사이의 협업
- 행동 명세(사용자 스토리 기반의 요구사항) 작성
- 행동 명세의 테스트화
- 테스트의 문서화